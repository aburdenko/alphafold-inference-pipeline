#!/usr/bin/env python
# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Predict runner."""

import io
import logging
import os
import numpy as np
import sys
import pickle
import haiku as hk
import time

from typing import Any, Mapping, MutableMapping, Optional, Sequence, Union, Tuple

from alphafold.model import config
from alphafold.model import model
from alphafold.model import utils
from alphafold.common import residue_constants
from alphafold.common import protein



def _get_model_haiku_params(model_name: str,
                            params_dir: str):
    """Get the Haiku parameters from a model name."""

    path = os.path.join(params_dir, f'params_{model_name}.npz')
    with open(path, 'rb') as f:
        params = np.load(io.BytesIO(f.read()), allow_pickle=False)

    return utils.flat_params_to_haiku(params)


def _load_features(features_path):
    with open(features_path, 'rb') as f:
        features = pickle.load(f)
    return features


def predict(
    model_features_path: str,
    model_params_path: str,
    model_name: str,
    num_ensemble: int,
    random_seed: int,
) -> Tuple[Mapping, Mapping]:

    model_config = config.model_config(model_name)

    # we assume  a monomer pipeline in a POC
    model_config.data.eval.num_ensemble = num_ensemble
    model_params = _get_model_haiku_params(
        model_name=model_name, params_dir=model_params_path)
    model_runner = model.RunModel(model_config, model_params)

    features = _load_features(model_features_path)
    processed_feature_dict = model_runner.process_features(
        raw_features=features,
        random_seed=random_seed
    )
    prediction_result = model_runner.predict(
        feat=processed_feature_dict,
        random_seed=random_seed
    )

    plddt = prediction_result['plddt']
    plddt_b_factors = np.repeat(
        plddt[:, None], residue_constants.atom_type_num, axis=-1)
    unrelaxed_structure= protein.from_prediction(
        features=processed_feature_dict,
        result=prediction_result,
        b_factors=plddt_b_factors,
        remove_leading_feature_dimension=not model_runner.multimer_mode)
    unrelaxed_pdbs = protein.to_pdb(unrelaxed_structure)

    return prediction_result, unrelaxed_pdbs


def _main(
    model_features_path: str,
    model_params_path: str,
    model_name: str,
    num_ensemble: int,
    random_seed: int,
    raw_prediction_path: str,
    unrelaxed_protein_path: str,
):
    logging.info(f'Running prediction using model {model_name}')
    prediction_result, unrelaxed_pdbs = predict(
        model_features_path=model_features_path,
        model_params_path=model_params_path,
        model_name=model_name,
        num_ensemble=num_ensemble,
        random_seed=random_seed
    )

    logging.info(f'Writing model {model_name} prediction to {raw_prediction_path}') 
    with open(raw_prediction_path, 'wb') as f:
        pickle.dump(prediction_result, f, protocol=4)

    logging.info(f'Writing unrelaxed protein generated by {model_name} to {unrelaxed_protein_path}') 
    with open(unrelaxed_protein_path, 'w') as f:
        f.write(unrelaxed_pdbs)
     

if __name__=='__main__':
    logging.basicConfig(format='%(asctime)s - %(message)s',
                        level=logging.INFO, 
                        datefmt='%d-%m-%y %H:%M:%S',
                        stream=sys.stdout)

    random_seed = int(os.getenv('RANDOM_SEED', '0'))

    # TODO: Do something more intelligent with random seed
    if not random_seed:
        random_seed = int(os.environ['MODEL_NAME'][-1])

    _main(
        model_features_path=os.environ['FEATURES_PATH'],
        model_params_path=os.environ['MODEL_PARAMS_PATH'],
        model_name=os.environ['MODEL_NAME'],
        num_ensemble=int(os.getenv('NUM_ENSEMBE', '1')),
        random_seed=random_seed,
        raw_prediction_path=os.environ['RAW_PREDICTION_PATH'],
        unrelaxed_protein_path=os.environ["UNRELAXED_PROTEIN_PATH"]
    )